SPEC

0. Headers  
â€¢ Each assistant message ends with a âœ…Compliance checklist â€“ perâ€‘item notes explaining how the current reply complies with or does not touch each rule.  
â€¢ No content is required at the beginning of the message.

1. Global hash (self.global_hash)  
â€¢ Exactly one per process/run.  
â€¢ All artefacts for the current run live in  
artifacts/run_<self.global_hash>/<step_name>/ (no hashes in any filename unless necessary â€“ see Â§73).


1A. Hash-generation rules (deterministic, no timestamps)  

â€¢ Reproducible: identical inputs â‡’ identical hash.  
â€¢ Absolutely NO timestamp/UUID/entropy.  
â€¢ A human-readable created_at.txt may be written alongside artefactsâ€”never used in hash generation.  

Training (self.train_mode=True):  
self.global_hash = make_param_hash(full_config)
  
Inference (self.train_mode=False):  

key_tuple = (
model_name,
model_hash,
dataset_name,
tuple(sorted(feature_names)),
extra_inference_settings
)

self.global_hash = make_param_hash(key_tuple)

make_param_hash(obj)= first12hex chars of SHA-256 over, but it's fixed for smoke tests (say, '100000000001' for the run folder used for all smoke test artifacts)

json.dumps(obj, sort_keys=True, default=str).


2. Perâ€‘step hashesâŒ  
â€¢ Do not generate, embed, or store hashes at the step level.
3. Bookâ€‘keeping objects  
â€¢ self.pathsâ†’ directory for each step (globalâ€‘hash path).  
â€¢ self.artifactsâ†’ manifestâ€‘style dict per step.  
â€¢ self.hashes is removed  ; comment legacy calls with  
# removed: self.hashes no longer used.
4. Trainingâ€‘run hash (self.global_train_hash)  
python
if self.train_mode:  # training
self.global_train_hash = self.global_hash
else:  # inference
self.global_train_hash = self.config["train_hash"]
  
Inference loads artefacts from  
artifacts/run_<self.global_train_hash>/<step_name>/.
5. train_mode logic  
Training:  
â€¢ Run full computation; write outputs (engineered.csv, dropped_features.json, manifest.json, etc.).
Inference:  
1. Reuse artefact if it already exists in the inference run  .  
2. Else load it from the training run (self.global_train_hash).  
3. Else raise a clear error.  
â€¢ Never recompute from raw during inference.  
â€¢ Never overwrite training artefacts.

6. MLflow
â€¢ Always active in train and inference.  
â€¢ Log the entire step directory as a single artefact.

7. log_registry  
Call signature: log_registry(step, self.global_hash, â€¦).

8. Codeâ€‘change etiquette  
â€¢ Work on one file at a time  â€”the user supplies the file.  
â€¢ Touch only lines required for spec compliance.  
â€¢ Commentâ€‘out, never delete, any removed/changed line.  
â€¢ Every .py file must contain a functional if __name__ == "__main__": block:  
â€“ Never delete or shorten an existing smoke test.  
â€“ Append new checks; keep originals intact.  
â€“ python <file>.py must run without error.

---

9. Randomness discipline  
â€¢ All random seeds live in the config.  
â€¢ No hidden RNG calls.

---

10. Function-name continuity  
â€¢ Do not silently replace public functions.  
â€¢ If refactoring is required, rename the old implementation (e.g., old_<name> or <name>_deprecated) and keep the public interface.

---

11. Imports  
â€¢ Always use absolute imports inside the projectâ€”never relative (from .foo import â€¦).

---

12. Hash helper naming  
â€¢ The deterministic helper is make_param_hash  .

---

13. Docstrings & type hints  
â€¢ Never delete existing ones.  
â€¢ Update/add them whenever behaviour changes.

---

14. Skipâ€‘guard positioning & purpose  
python
if os.path.exists(manifest_fp):
load_and_return()
  
Must appear before any compute logic to avoid recomputation and accidental overwrites.

---

15. Changeâ€‘delivery rules  
a. Return the full, selfâ€‘contained replacement file inside a fenced code block.  
b. Include a â€œWhat changed & whyâ€ section.  
c. Provide a unified diff only when explicitly requested.  
d. Introduce no new classes/functions/flags unless explicitly asked.

---

16. Reply content  
â€¢ Detail is welcomeâ€”do not sacrifice correctness for brevity.  
â€¢ Never omit essential logic.  
â€¢ No unsolicited features beyond what the spec requires.

---

17. Shared test hash for smoke tests  
â€¢ Define a constant (e.g., DEFAULT_TEST_HASH) used across all __main__ blocks so artefacts chain cleanly.

---

18. Avoid trivial examples in smoke tests  
â€¢ Tests must exercise:  
â€“ Multiâ€‘row, multiâ€‘type inputs.  
â€“ Missing values.  
â€“ Invalid config scenarios.

---

19. __main__ blocks must test:  
â€¢ Training with no preâ€‘existing artefacts (fresh run).  
â€¢ Training with artefacts (verifies skipâ€‘guard).  
â€¢ Inference with required artefacts.  
â€¢ Inference without artefacts (must fail clearly).

---

20. Migration to test files  
â€¢ __main__ smoke tests serve as the interim test suite.  
â€¢ They will be migrated to formal tests/ modules in the next phase.

---

21. Separate delivery of __main__ blocks  
â€¢ When you modify a file, deliver:  
1. One message containing the file body without the __main__ block.  
2. A followâ€‘up message containing only the __main__ block.

---

22. Optional shared test helpers  
â€¢ Common logic (e.g., loading configs, asserting errors, shared hash) may live in utils.py for now.  
â€¢ They will move to test_helpers.py later.

---

23. Additional runtime checks (timeâ€‘permitting)  
â€¢ Perâ€‘run audit report (steps completed, paths used).  
â€¢ Artefact validation (existence & schema).  
â€¢ config.json snapshot saved per step.  
â€¢ hash.txt echo file in run_<hash>/.

---

24. Smokeâ€‘test dependency discipline  
a. Prefer selfâ€‘contained smoke testsâ€”able to run with only standard library plus the file under test.  
b. If selfâ€‘containment is impractical, a smoke test may import or invoke only those pipeline steps that have already been implemented and validated  .  
â€“ Never depend on steps scheduled for future implementation; otherwise, the current file cannot be verified in isolation.  
c. All smoke tests must honor the shared DEFAULT_TEST_HASH (specÂ§17) so artefacts generated by earlierâ€‘step tests are reusable by laterâ€‘step tests executed sequentially.

0. Headers  
â€¢ Each assistant message ends with a âœ…Compliance checklist â€“ perâ€‘item notes explaining how the current reply complies or does not touch each rule.



25. File Naming Discipline  
â€¢ All outputs must be stored in a folder named with the hash:  
artifacts/<step_name>/<step_name>_<param_hash>/  
â€¢ Structured files (e.g., .json, .yaml) must include "param_hash" inside their content.  
â€¢ Unstructured files (e.g., .csv, .png) must not include the hash in their filename if the enclosing folder already includes the hash.  
â€¢ Only include the hash in filenames if:
â€“ The file may be viewed or used outside its folder  
â€“ Or the folder does not include the hash  

26. Print Statements and Comment Retention  
â€¢ Never remove or alter print statements unless they are provably redundant or explicitly overridden.  
â€¢ Print statements are treated as user-facing output and must be preserved verbatim.  
â€¢ Do not delete comments near print statements unless they merely restate that the line is a print.  
â€¢ If a comment adds nuance, rationale, or context, it must be kept.


27. Intent Respect  
â€¢ Assume all filenames, comments, and print statements are intentional unless they clearly violate spec or correctness.  
â€¢ Do not rename, reword, or delete existing lines of this kind unless explicitly told to, or unless needed for spec enforcement.

Excellent updates â€” here's the refined **SPEC Addendum** with your two new clarifications incorporated:

---

## ğŸ“œ SPEC Addendum: Strict Intent Preservation and Integrated Run Continuity

### âœ… 28. Explicit Modification Protocol
Before **any** structural code change (e.g., refactor, rename, removal):
i. State **which SPEC rule mandates the change**
ii. Show **minimal diff** or patch proposal
iii. Wait for **explicit user approval**



### ğŸ”’ 29. Preserve Modularity and Structure
- **Do not collapse, inline, or refactor helper functions**, even if small or seemingly redundant.
- **Preserve all original code structure**, function boundaries, and control flow, unless SPEC violations demand otherwise.
- Never reorder, deduplicate, or optimize code blocks unless explicitly approved.

### ğŸ§¯ 30. No Unsolicited Changes â€” Except With Approval
- **Do not simplify, optimize, or â€œclean upâ€ code** without user permission.
- **Improvements may be proposed** if they **add functionality** (e.g., new features, hooks, toggles), but must:
  - Be clearly marked as suggestions
  - Not remove or flatten existing functionality
  - Be approved before implementation

### âœï¸ 31. Comments, Docstrings, and Style
- **Preserve all existing comments and docstrings**, including inline and block comments.
- Only add/update docstrings if missing and required by SPEC Â§13.
- Never remove a comment unless it is provably incorrect due to a SPEC-required fix or explicitly marked as redundant by the user.

### ğŸ“‚ 32. Skipâ€‘guard Discipline
- When enforcing SPEC Â§14 (skipâ€‘guard first), only move or gate the **minimum required logic**.
- Do **not** restructure entire functions to satisfy skipâ€‘guard unless absolutely necessary.

### ğŸ” 33. Hash & Artifact Pathing
- All outputs must go to `artifacts/run_<hash>/<step>/` (SPEC Â§1).
- **Do not delete or overwrite** contents of `run_<hash>/` folders when executing a new step.
  - Steps must only write to their own `<step>/` subfolder.
  - Other subfolders and files in `run_<hash>/` must remain untouched.
- This enables full pipeline validation across steps using shared state and common hashes.

### ğŸ§ª 34. Smoke Tests
- `__main__` blocks must test full scenarios without breaking continuity across steps.
- All smoke tests must set and respect `DEFAULT_TEST_HASH` (SPEC Â§17).
- If an existing test block exists, do **not** replace it without user approval.

### ğŸ§· 35. Frozen by Default
- If unsure whether a change is allowed, **do nothing** and ask first.
- Do **not** assume silent permission to restructure or "improve" logic.

